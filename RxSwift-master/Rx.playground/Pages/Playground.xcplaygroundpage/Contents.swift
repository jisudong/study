/*:
 > # IMPORTANT: To use **Rx.playground**:
 1. Open **Rx.xcworkspace**.
 1. Build the **RxSwift-macOS** scheme (**Product** â†’ **Build**).
 1. Open **Rx** playground in the **Project navigator**.
 1. Show the Debug Area (**View** â†’ **Debug Area** â†’ **Show Debug Area**).
 */
import RxSwift
/*:
 # Try Yourself
 
 It's time to play with Rx ğŸ‰
 */
playgroundShouldContinueIndefinitely()

example("Try yourself") {
  // let disposeBag = DisposeBag()
  _ = Observable.just("Hello, RxSwift!")
    .debug("Observable")
    .subscribe()
    // .disposed(by: disposeBag) // If dispose bag is used instead, sequence will terminate on scope exit
}


// MARK: Creating and Subscribing to Observables

example("never") {
    let disposeBag = DisposeBag()
    Observable<String>.never()
        .subscribe { _ in
            print("this will never be printed")
        }
        .disposed(by: disposeBag)
}


example("empty") {
    let disposeBag = DisposeBag()
    Observable<Int>.empty()
        .subscribe { event in
            print(event)
        }
        .disposed(by: disposeBag)
}

example("just") {
    let disposeBag = DisposeBag()
    Observable.just("ğŸ”´")
        .subscribe({ (event) in
            print(event)
        })
        .disposed(by: disposeBag)
}

example("of") {
    let disposeBag = DisposeBag()
    Observable.of("ğŸ¶", "ğŸ±", "ğŸ­", "ğŸ¹")
        .subscribe(onNext: { element in
            print(element)
        })
        .disposed(by: disposeBag)
}

example("from") {
    let disposeBag = DisposeBag()
    Observable.from(["ğŸ¶", "ğŸ±", "ğŸ­", "ğŸ¹"])
        .subscribe(onNext: {  print($0) })
        .disposed(by: disposeBag)
}

example("create") {
    let disposeBag = DisposeBag()
    let myJust = { (element: String) -> Observable<String> in
        return Observable.create { observer in
            observer.on(.next(element))
            observer.on(.completed)
            return Disposables.create()
        }
    }
    myJust("ğŸ”´")
        .subscribe({ print($0) })
        .disposed(by: disposeBag)
}

example("range") {
    let disposeBag = DisposeBag()
    Observable.range(start: 1, count: 10)
        .subscribe { print($0) }
        .disposed(by: disposeBag)
}

example("repeatElement") {
    let disposeBag = DisposeBag()
    Observable.repeatElement("ğŸ”´")
        .take(3)
        .subscribe { print($0) }
        .disposed(by: disposeBag)
}

example("generate") {
    let disposeBag = DisposeBag()
    Observable.generate(
            initialState: 0,
            condition: { $0 < 3 },
            iterate: { $0 + 1 }
        )
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
}

example("deferred") {
    let disposeBag = DisposeBag()
    var count = 1
    
    let deferredSequence = Observable<String>.deferred {
        print("creating \(count)")
        count += 1
        
        return Observable.create { observer in
            observer.onNext("ğŸ¶")
            observer.onNext("ğŸ±")
            observer.onNext("ğŸµ")
            return Disposables.create()
        }
    }
    
    deferredSequence
        .subscribe { print($0) }
        .disposed(by: disposeBag)
    
    deferredSequence
        .subscribe { print($0) }
        .disposed(by: disposeBag)
}

example("error") {
    let disposeBag = DisposeBag()
    Observable<Int>.error(TestError.test)
        .subscribe { print($0) }
        .disposed(by: disposeBag)
}

example("doOn") {
    let disposeBag = DisposeBag()
    Observable.of("ğŸ", "ğŸ", "ğŸŠ", "ğŸ‹")
        .do(
            onNext: { print("Intercepted", $0) },
            onError: { print("Intercepted error", $0) },
            onCompleted: { print("Completed") }
        )
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
}


// MARK: Working with Subject

extension ObservableType {
    func addObserver(_  id: String) -> Disposable {
        return subscribe { print("Subscription;", id, "Event:", $0) }
    }
}

example("PublishSubject") {
    let disposeBag = DisposeBag()
    let subject = PublishSubject<String>()
    
    subject.addObserver("1").disposed(by: disposeBag)
    subject.onNext("ğŸ¶")
    subject.onNext("ğŸ±")
    
    subject.addObserver("2").disposed(by: disposeBag)
    subject.onNext("ğŸ…°ï¸")
    subject.onNext("ğŸ…±ï¸")
}

example("ReplaySubject") {
    let disposeBag = DisposeBag()
    let subject = ReplaySubject<String>.create(bufferSize: 1)
    
    subject.addObserver("1").disposed(by: disposeBag)
    subject.onNext("ğŸ¶")
    subject.onNext("ğŸ±")
    
    subject.addObserver("2").disposed(by: disposeBag)
    subject.onNext("ğŸ…°ï¸")
    subject.onNext("ğŸ…±ï¸")
}

example("BehaviorSubject") {
    let disposeBag = DisposeBag()
    let subject = BehaviorSubject(value: "ğŸ”´");
    
    subject.addObserver("1").disposed(by: disposeBag)
    subject.onNext("ğŸ¶")
    subject.onNext("ğŸ±")
    
    subject.addObserver("2").disposed(by: disposeBag)
    subject.onNext("ğŸ…°ï¸")
    subject.onNext("ğŸ…±ï¸")
    
    subject.addObserver("3").disposed(by: disposeBag)
    subject.onNext("ğŸ")
    subject.onNext("ğŸŠ")
}

example("Variable") {
    let disposeBag = DisposeBag()
    let variable = Variable("ğŸ”´")
    
    variable.asObservable().addObserver("1").disposed(by: disposeBag)
    variable.value = "ğŸ¶"
    variable.value = "ğŸ±"

    variable.asObservable().addObserver("2").disposed(by: disposeBag)
    variable.value = "ğŸ…°ï¸"
    variable.value = "ğŸ…±ï¸"
}


// MARK: Combination Operators

example("startWith") {
    let disposeBag = DisposeBag()
    
    Observable.of("ğŸ¶", "ğŸ±", "ğŸ­", "ğŸ¹")
        .startWith("1ï¸âƒ£")
        .startWith("2ï¸âƒ£")
        .startWith("3ï¸âƒ£", "ğŸ…°ï¸", "ğŸ…±ï¸")
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
}

example("merge") {
    let disposeBag = DisposeBag()
    
    let subject1 = PublishSubject<String>()
    let subject2 = PublishSubject<String>()
    
    Observable.of(subject1, subject2)
        .merge()
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
    
    subject1.onNext("ğŸ…°ï¸")
    
    subject1.onNext("ğŸ…±ï¸")
    
    subject2.onNext("â‘ ")
    
    subject2.onNext("â‘¡")
    
    subject1.onNext("ğŸ†")
    
    subject2.onNext("â‘¢")
}

example("zip") {
    let disposeBag = DisposeBag()
    
    let stringSubject = PublishSubject<String>()
    let intSubject = PublishSubject<Int>()
    
    Observable.zip(stringSubject, intSubject) { stringElement, intElement in
            "\(stringElement) \(intElement)"
        }
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
    
    stringSubject.onNext("ğŸ…°ï¸")
    stringSubject.onNext("ğŸ…±ï¸")
    
    intSubject.onNext(1)
    intSubject.onNext(2)

    stringSubject.onNext("ğŸ†")
    intSubject.onNext(3)
}

example("combineLatest") {
    let disposeBag = DisposeBag()
    
    let stringSubject = PublishSubject<String>()
    let intSubject = PublishSubject<Int>()
    
    Observable.combineLatest(stringSubject, intSubject) { stringElement, intElement in
            "\(stringElement) \(intElement)"
        }
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
    
    stringSubject.onNext("ğŸ…°ï¸")
    
    stringSubject.onNext("ğŸ…±ï¸")
    intSubject.onNext(1)

    intSubject.onNext(2)
    
    stringSubject.onNext("ğŸ†")
}

example("Array.combineLatest") {
    let disposeBag = DisposeBag()
    
    let stringObservable = Observable.just("ğŸ”´")
    let fruitObservable = Observable.from(["ğŸ", "ğŸ", "ğŸŠ"])
    let animalObservable = Observable.of("ğŸ¶", "ğŸ±", "ğŸ­", "ğŸ¹")
    
    
    
    Observable.combineLatest([stringObservable, fruitObservable, animalObservable]) {
            "\($0[0]) \($0[1]) \($0[2])"
        }
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
}

example("switchLatest") {
    let disposeBag = DisposeBag()
    
    let subject1 = BehaviorSubject(value: "âš½ï¸")
    let subject2 = BehaviorSubject(value: "ğŸ")
    
    let variable = Variable(subject1)
    
    variable.asObservable()
        .switchLatest()
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
    
    subject1.onNext("ğŸˆ")
    subject1.onNext("ğŸ€")
    
    variable.value = subject2
    
    subject1.onNext("âš¾ï¸")
    
    subject2.onNext("ğŸ")
}


// MARK: Transforming Operators

example("map") {
    let disposeBag = DisposeBag()
    Observable.of(1, 2, 3)
        .map { $0 * $0 }
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
}

example("flatMap and flatMapLatest") {
    let disposeBag = DisposeBag()
    
    struct Player {
        var score: Variable<Int>
    }
    
    let ğŸ‘¦ğŸ» = Player(score: Variable(80))
    let ğŸ‘§ğŸ¼ = Player(score: Variable(90))
    let ren = Player(score: Variable(91))
    
    let player = Variable(ğŸ‘¦ğŸ»)
    
    player.asObservable()
        .flatMap { $0.score.asObservable() }
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
    
    ğŸ‘¦ğŸ».score.value = 85
    
    player.value = ğŸ‘§ğŸ¼
    
    ğŸ‘¦ğŸ».score.value = 95
    
    ğŸ‘§ğŸ¼.score.value = 100
    
    player.value = ren
    
    ğŸ‘¦ğŸ».score.value = 92
    
    ğŸ‘§ğŸ¼.score.value = 93
    
    ren.score.value = 94
}


// MARK: Filtering and Conditional Operators

example("filter") {
    let disposeBag = DisposeBag()
    
    Observable.of(
        "ğŸ±", "ğŸ°", "ğŸ¶",
        "ğŸ¸", "ğŸ±", "ğŸ°",
        "ğŸ¹", "ğŸ¸", "ğŸ±")
        .filter { $0 == "ğŸ±" }
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
}

example("distinctUntilChanged") {
    let disposeBag = DisposeBag()
    
    Observable.of("ğŸ±", "ğŸ·", "ğŸ±", "ğŸ±", "ğŸ±", "ğŸµ", "ğŸ±")
        .distinctUntilChanged()
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
}

example("elementAt") {
    let disposeBag = DisposeBag()
    
    Observable.of("ğŸ±", "ğŸ°", "ğŸ¶", "ğŸ¸", "ğŸ·", "ğŸµ")
        .elementAt(3)
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
}

example("single") {
    let disposeBag = DisposeBag()
    
    Observable.of("ğŸ±", "ğŸ°", "ğŸ¶", "ğŸ¸", "ğŸ·", "ğŸµ")
        .single()
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
}

example("single with conditions") {
    let disposeBag = DisposeBag()
    
    Observable.of("ğŸ±", "ğŸ°", "ğŸ¶", "ğŸ¸", "ğŸ·", "ğŸµ")
        .single { $0 == "ğŸ¸" }
        .subscribe { print($0) }
        .disposed(by: disposeBag)
    
    Observable.of("ğŸ±", "ğŸ°", "ğŸ¶", "ğŸ¸", "ğŸ·", "ğŸµ")
        .single { $0 == "ğŸ°" }
        .subscribe { print($0) }
        .disposed(by: disposeBag)
    
    Observable.of("ğŸ±", "ğŸ°", "ğŸ¶", "ğŸ¸", "ğŸ·", "ğŸµ")
        .single { $0 == "ğŸ”µ" }
        .subscribe { print($0) }
        .disposed(by: disposeBag)
}

example("take") {
    let disposeBag = DisposeBag()
    
    Observable.of("ğŸ±", "ğŸ°", "ğŸ¶", "ğŸ¸", "ğŸ·", "ğŸµ")
        .take(3)
        .subscribe { print($0) }
        .disposed(by: disposeBag)
}

example("takeLast") {
    let disposeBag = DisposeBag()
    
    Observable.of("ğŸ±", "ğŸ°", "ğŸ¶", "ğŸ¸", "ğŸ·", "ğŸµ")
        .takeLast(3)
        .subscribe { print($0) }
        .disposed(by: disposeBag)
}

example("takeWhile") {
    let disposeBag = DisposeBag()
    
    Observable.of(1, 2, 3, 4, 5, 6)
        .takeWhile { $0 < 4 }
        .subscribe { print($0) }
        .disposed(by: disposeBag)
}

example("takeUntil") {
    let disposeBag = DisposeBag()
    
    let sourceSequence = PublishSubject<String>()
    let referenceSequence = PublishSubject<String>()
    
    sourceSequence
        .takeUntil(referenceSequence)
        .subscribe { print($0) }
        .disposed(by: disposeBag)
    
    sourceSequence.onNext("ğŸ±")
    sourceSequence.onNext("ğŸ°")
    sourceSequence.onNext("ğŸ¶")
    
    referenceSequence.onNext("ğŸ”´")
    
    sourceSequence.onNext("ğŸ¸")
    sourceSequence.onNext("ğŸ·")
    sourceSequence.onNext("ğŸµ")
}

example("skip") {
    let disposeBag = DisposeBag()
    
    Observable.of("ğŸ±", "ğŸ°", "ğŸ¶", "ğŸ¸", "ğŸ·", "ğŸµ")
        .skip(2)
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
}

example("skipWhile") {
    let disposeBag = DisposeBag()
    
    Observable.of(1, 2, 3, 4, 5, 6)
        .skipWhile { $0 < 4 }
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
}

example("skipWhileWithIndex") {
    let disposeBag = DisposeBag()
    
    Observable.of("ğŸ±", "ğŸ°", "ğŸ¶", "ğŸ¸", "ğŸ·", "ğŸµ")
        .skipWhileWithIndex({ (element, index) in
            index < 3
        })
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
}

example("skipUntil") {
    let disposeBag = DisposeBag()
    
    let sourceSequence = PublishSubject<String>()
    let referenceSequence = PublishSubject<String>()
    
    sourceSequence
        .skipUntil(referenceSequence)
        .subscribe(onNext: { print($0)})
        .disposed(by: disposeBag)
    
    sourceSequence.onNext("ğŸ±")
    sourceSequence.onNext("ğŸ±")
    sourceSequence.onNext("ğŸ¶")
    
    referenceSequence.onNext("ğŸ”´")
    
    sourceSequence.onNext("ğŸ¸")
    sourceSequence.onNext("ğŸ·")
    sourceSequence.onNext("ğŸµ")
}


// MARK: Mathematical and Aggregate Operators

example("toArray") {
    let disposeBag = DisposeBag()
    
    Observable.range(start: 1, count: 10)
        .toArray()
        .subscribe { print($0) }
        .disposed(by: disposeBag)
}

example("reduce") {
    let disposeBag = DisposeBag()
    
    Observable.of(10, 100, 1000)
        .reduce(1, accumulator: +)
        .subscribe(onNext: { print($0) })
        .disposed(by: disposeBag)
}

example("concat") {
    let disposeBag = DisposeBag()
    
    let subject1 = BehaviorSubject(value: "ğŸ")
    let subject2 = BehaviorSubject(value: "ğŸ¶")
    
    let variable = Variable(subject1)
    
    variable.asObservable()
        .concat()
        .subscribe { print($0) }
        .disposed(by: disposeBag)
    
    subject1.onNext("ğŸ")
    subject1.onNext("ğŸŠ")
    
    variable.value = subject2
    
    subject2.onNext("I would be ignored")
    subject2.onNext("ğŸ±")
    
    subject1.onCompleted()
    
    subject2.onNext("ğŸ­")
}


// MARK: Connectable Operators

func sampleWithoutConnectableOperators() {
    printExampleHeader(#function)
    
    let interval = Observable<Int>.interval(1, scheduler: MainScheduler.instance)
    
    _ = interval
        .subscribe(onNext: { print("Subscription: 1, Event: \($0)") })
    
    delay(5) {
        _ = interval
            .subscribe(onNext: { print("Subscription: 2, Event: \($0)") })
    }
}

//sampleWithoutConnectableOperators()

func sampleWithPublish() {
    printExampleHeader(#function)
    
    let intSequence = Observable<Int>.interval(1, scheduler: MainScheduler.instance)
        .publish()
    
    _ = intSequence
        .subscribe(onNext: { print("Subscription 1:, Event: \($0)") })
    
    delay(2) {
        _ = intSequence.connect()
    }
    
    delay(4) {
        _ = intSequence
            .subscribe(onNext: { print("Subscription 2:, Event: \($0)") })
    }
    
    delay(6) {
        _ = intSequence
            .subscribe(onNext: { print("Subscription 3:, Event: \($0)") })
    }
}

//sampleWithPublish()

func sampleWithReplayBuffer() {
    printExampleHeader(#function)
    
    let intSequence = Observable<Int>.interval(1, scheduler: MainScheduler.instance)
        .replay(3)
    
    _ = intSequence
        .subscribe(onNext: { print("Subscription 1:, Event: \($0)") })
    
    delay(2) {
        _ = intSequence.connect()
    }
    
    delay(4) {
        _ = intSequence
            .subscribe(onNext: { print("Subscription 2:, Event: \($0)") })
    }
    
    delay(8) {
        _ = intSequence
            .subscribe(onNext: { print("Subscription 3:, Event: \($0)") })
    }
}

//sampleWithReplayBuffer()

func sampleWithMulticast() {
    printExampleHeader(#function)
    
    let subject = PublishSubject<Int>()
    
    _ = subject
        .subscribe(onNext: { print("Subject: \($0)") })
    
    let intSequence = Observable<Int>.interval(1, scheduler: MainScheduler.instance)
        .multicast(subject)
    
    _ = intSequence
        .subscribe(onNext: { print("\tSubscription 1:, Event: \($0)") })
    
    delay(2) {
        _ = intSequence.connect()
    }

    delay(4) {
        _ = intSequence
            .subscribe(onNext: { print("\tSubscription 2:, Event: \($0)") })
    }
    
    delay(6) {
        _ = intSequence
            .subscribe(onNext: { print("\tSubscription 3:, Event: \($0)") })
    }
}

//sampleWithMulticast()



